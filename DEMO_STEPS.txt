Secure‑Boot Dilithium: Piece‑by‑piece Demo
=========================================

0) One‑time prep
Command
  mkdir -p out
  ./tools/gen_keys_c out/pub.key out/sec.key
  tools/gen_otp_header.sh out/pub.key
  make rom_mock
Why
  Generate keypair, bake pubkey into OTP header, build ROM mock.
Expected
  “wrote rom/otp_pk.h” and a “rom_mock” binary.

1) Clean image → PASS
Command
  dd if=/dev/urandom of=out/fw.clean bs=4096 count=1
  ./tools/sign_fw_c out/fw.clean out/pub.key out/sec.key 11 out/hdr.clean
  printf '\x00\x00\x00\x00' > out/otp_counter.bin
  ./rom_mock out/hdr.clean out/fw.clean out/hdr.clean out/fw.clean
Why
  Fresh payload, version=11, min‑version reset.
Expected
  PASS.

2) Payload tamper → FAIL, then control PASS
Command
  cp out/fw.clean out/fw.tamper
  python - <<'PY'
p="out/fw.tamper"; b=bytearray(open(p,"rb").read()); b[0]^=0xFF; open(p,"wb").write(b)
PY
  ./rom_mock out/hdr.clean out/fw.tamper out/hdr.clean out/fw.tamper   # FAIL
  ./rom_mock out/hdr.clean out/fw.clean  out/hdr.clean out/fw.clean    # PASS
Why
  Signature no longer matches; control confirms baseline.
Expected
  First FAIL, second PASS.

3) Header/signature tamper → FAIL
Command
  ./tools/sign_fw_c out/fw.clean out/pub.key out/sec.key 1 out/hdr.good
  cp out/hdr.good out/hdr.bad
  python - <<'PY'
p="out/hdr.bad"; b=bytearray(open(p,"rb").read()); b[8]^=1; open(p,"wb").write(b)
PY
  ./rom_mock out/hdr.bad out/fw.clean out/hdr.bad out/fw.clean
Why
  Corrupted signed bytes invalidate signature.
Expected
  FAIL.

4) Rollback protection
Command
  printf '\x00\x00\x00\x00' > out/otp_counter.bin
  ./tools/sign_fw_c out/fw.clean out/pub.key out/sec.key 5 out/hdr.v5
  ./rom_mock out/hdr.v5 out/fw.clean out/hdr.v5 out/fw.clean           # PASS
  ./tools/sign_fw_c out/fw.clean out/pub.key out/sec.key 4 out/hdr.v4
  ./rom_mock out/hdr.v4 out/fw.clean out/hdr.v4 out/fw.clean           # FAIL
  ./tools/sign_fw_c out/fw.clean out/pub.key out/sec.key 6 out/hdr.v6
  ./rom_mock out/hdr.v6 out/fw.clean out/hdr.v6 out/fw.clean           # PASS
Why
  OTP stores highest seen version; older images blocked.
Expected
  v5 PASS, v4 FAIL, v6 PASS.

5) A/B slots: prefer newer, then fallback
Command
  dd if=/dev/urandom of=out/fw.A bs=4096 count=1
  dd if=/dev/urandom of=out/fw.B bs=4096 count=1
  ./tools/sign_fw_c out/fw.A out/pub.key out/sec.key 10 out/hdr.A
  ./tools/sign_fw_c out/fw.B out/pub.key out/sec.key 11 out/hdr.B
  ./rom_mock out/hdr.A out/fw.A out/hdr.B out/fw.B                    # PASS; choose B
  python - <<'PY'
p="out/fw.B"; b=bytearray(open(p,"rb").read()); b[1]^=0xAA; open(p,"wb").write(b)
PY
  ./rom_mock out/hdr.A out/fw.A out/hdr.B out/fw.B                    # PASS; fallback to A
Why
  Boot picks higher version; on failure, falls back.
Expected
  First boots B, second boots A.

6) Public‑key mismatch → FAIL
Command
  ./tools/gen_keys_c out/pub2.key out/sec2.key
  ./tools/sign_fw_c out/fw.clean out/pub2.key out/sec2.key 1 out/hdr.otherkey
  ./rom_mock out/hdr.otherkey out/fw.clean out/hdr.otherkey out/fw.clean
Why
  Signed by key not in OTP.
Expected
  FAIL.

7) Scripted summary (sanity)
Command
  ./tools/test_matrix.sh
Why
  Minimal PASS/expected‑FAIL replay.
Expected
  PASS where expected, one rollback FAIL by design.
